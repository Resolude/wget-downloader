#!/usr/bin/env bash

USAGE="Usage: $(basename "$0") [OPTION]... FILE";

# Will change if argument is passed to specify alternate start point
series_name="";
season=1;
episode=1;

# Program arguments (short)
SHORT=s:e:n:
# Program arguments (long)
LONG=season:,episode:,name:

# Error codes
E_INVALID_ARGS=1;
E_MISSING_FILE=2;
E_EMPTY_FILE=3; 
E_GETOPT_FAIL=4;

# Regex for capturing the episode number from the URL
EPS_NUMBER_REGEX="_([0-9]+)\.mp4$";
# Regex for capturing the episode number (HD) from the URL
EPS_NUMBER_HD_REGEX="_([0-9]+)_hd\.mp4$";
# Regex for matching against invalid directory names
INVALID_DIR_REGEX="/";
# Regex matching line containing only numbers
NUMERIC_LINE_REGEX="^[0-9]+$";

# Gets the series name from the user.
# Auto-retry if an invalid name is used or if the name matches and existing directory.
get_series_name() {
    read -r -p "Enter series name: " series_name;

    if [[ "$series_name" =~ $INVALID_DIR_REGEX ]]; then
        echo "Error: Invalid series name. Remove illegal characters and try again.";
        get_series_name
    fi

    if [[ -d "$series_name" ]]; then
        echo "Series name matches existing directory. Try again.";
        get_series_name
    fi
}

if [[ $# -eq 0 ]]; then
    echo "$USAGE";
    exit "$E_INVALID_ARGS";
fi

getopt --test > /dev/null
if [[ $? -ne 4 ]]; then
    echo "$0: Fatal error. getopt --test failed.";
    exit "$E_GETOPT_FAIL";
fi

if ! PARSED=$(getopt --options $SHORT --longoptions $LONG --name "$0" -- "$@"); then
    # Wrong argument error has been printed to stdout, time to fail
    exit "$E_INVALID_ARGS";
fi

eval set -- "$PARSED";

while true; do
    case "$1" in
        -s|--season)
            if [[ ! "$2" =~ $NUMERIC_LINE_REGEX ]]; then
                echo "$0: Invalid season number.";
                exit "$E_INVALID_ARGS";
            fi

            season="$2";

            shift 2;
            ;;
        -e|--episode)
            if [[ ! "$2" =~ $NUMERIC_LINE_REGEX ]]; then
                echo "$0: Invalid episode number.";
                exit "$E_INVALID_ARGS";
            fi

            episode="$2";

            shift 2;
            ;;
        -n|--name)
            if [[ "$2" =~ $INVALID_DIR_REGEX ]]; then
                echo "$0: Invalid character in series name.";
                exit "$E_INVALID_ARGS";
            fi

            series_name="$2";

            shift 2;
            ;;
        --)
            shift;
            break;
            ;;
        *)
            echo "$0: Fatal error while parsing arguments. Report this bug.";
            exit "$E_INVALID_ARGS";
            ;;
    esac
done

if [[ $# -eq 0 ]]; then
    echo "$0: An input file is required.";
    exit "$E_INVALID_ARGS";
fi

# Validate input file
# TODO: Validate URLs in the input file
# If the input file doesn't exist or is empty
if [[ ! -s "$1" ]]; then
    # If the input file doesn't exist
    if [[ ! -f "$1" ]]; then
        echo "$0: Cannot locate file $1.";
        exit "$E_MISSING_FILE";
    else
        # File exists but is empty
        echo "$0: File $1 is empty. Nothing to do.";
        exit "$E_EMPTY_FILE";
    fi
fi

if [[ "$series_name" == "" ]]; then
    get_series_name;
fi

# Create parent and first season directories
mkdir -p ./"$series_name"/s"$season"/;

# While the input file has another URL
while IFS= read -r line || [[ -n "$line" ]]; do
    # If the input is a blank line, increment season
    if [[ "$line" == "" ]]; then
        season=$((season+1));
        mkdir -p ./"$series_name"/s"$season"/;
        # Restart episode counter for new season
        episode=1;
        # Get another line from the file, nothing more to do
        continue;
    fi

    # Bash regex to capture the episode number and assign it to eps_number
    # If no match, set eps_number to -1 so we know later that we didn't match
    if [[ "$line" =~ $EPS_NUMBER_REGEX ]]; then
        eps_number="${BASH_REMATCH[1]}";
    elif [[ "$line" =~ $EPS_NUMBER_HD_REGEX ]]; then
        eps_number="${BASH_REMATCH[1]}";
    else
        eps_number=-1;
    fi

    # Generate the file name with proper season/epsiode labeling e.g. 01, 02, 03
    if [[ $eps_number -ne -1 ]]; then
        filename=$(printf "$series_name-s%02de%02d_%d.mp4\n" "$season" "$episode" "$eps_number");
    else
        # We didn't find an episode number, don't include it in the file name
        filename=$(printf "$series_name-s%02de%02d.mp4\n" "$season" "$episode");
    fi

    # Get the file, appending non-verbose logging to log.txt, running in background
    # and specifying the file path
    wget --no-verbose -a log.txt -b -O ./"$series_name"/s"$season"/"$filename" "$line";

    episode=$((episode+1));
done < "$1"
